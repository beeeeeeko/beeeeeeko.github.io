[
  {
    "id": 1,
    "question": "RDBでインデックスを貼りすぎると起こりやすい問題はどれ？",
    "choices": [
      "SELECTが遅くなる",
      "INSERTやUPDATEが遅くなる",
      "ロックが完全に消える",
      "データの整合性が失われる"
    ],
    "answer": 1,
    "explanation": "インデックスは更新時にもメンテナンスが必要なため、書き込み性能が低下します。"
  },
  {
    "id": 2,
    "question": "トランザクション分離レベルで『ファントムリード』が発生する可能性があるのは？",
    "choices": [
      "READ UNCOMMITTED",
      "READ COMMITTED",
      "REPEATABLE READ",
      "SERIALIZABLE"
    ],
    "answer": 2,
    "explanation": "REPEATABLE READではファントムリードが発生するDB実装があります。"
  },
  {
    "id": 3,
    "question": "CPU使用率が低いのにレスポンスが遅い場合、最も疑うべきなのは？",
    "choices": [
      "メモリリーク",
      "I/O待ち",
      "GCが動いていない",
      "スレッド数が多すぎる"
    ],
    "answer": 1,
    "explanation": "I/O待ちはCPUを使わないため、CPU使用率は低く見えます。"
  },
  {
    "id": 4,
    "question": "Webアプリでステートレス設計が好まれる理由として最も適切なのは？",
    "choices": [
      "実装が簡単",
      "セキュリティが不要",
      "スケールアウトしやすい",
      "DBが不要になる"
    ],
    "answer": 2,
    "explanation": "ステートレスにすることでロードバランサ配下で容易にスケールできます。"
  },
  {
    "id": 5,
    "question": "メモリ使用量が徐々に増え続ける場合に疑うべき現象は？",
    "choices": [
      "CPUスパイク",
      "デッドロック",
      "メモリリーク",
      "I/Oスロットリング"
    ],
    "answer": 2,
    "explanation": "解放されないオブジェクトが溜まり続けるとメモリリークが発生します。"
  },

  {
    "id": 6,
    "question": "HTTPS通信で行われていないものはどれ？",
    "choices": [
      "サーバ証明書の検証",
      "通信内容の暗号化",
      "DNSの暗号化",
      "鍵交換"
    ],
    "answer": 2,
    "explanation": "DNSはHTTPSとは別で、DoHなどを使わない限り暗号化されません。"
  },
  {
    "id": 7,
    "question": "KubernetesでPodが頻繁に再起動する場合、まず確認すべきものは？",
    "choices": [
      "Service定義",
      "Liveness Probe",
      "ConfigMap",
      "Ingress設定"
    ],
    "answer": 1,
    "explanation": "Liveness Probe失敗によりPodが再起動されるケースが多いです。"
  },
  {
    "id": 8,
    "question": "N+1問題が発生する主な原因は？",
    "choices": [
      "インデックス不足",
      "キャッシュ不足",
      "ORMの使い方",
      "ネットワーク遅延"
    ],
    "answer": 2,
    "explanation": "ORMでループ内にクエリが発行される設計が主因です。"
  },
  {
    "id": 9,
    "question": "キャッシュの整合性を保つ方法として最も一般的なのは？",
    "choices": [
      "定期的に全削除",
      "TTLを設定する",
      "常に手動更新",
      "キャッシュを使わない"
    ],
    "answer": 1,
    "explanation": "TTLは実装コストが低く、現実的な整合性管理方法です。"
  },
  {
    "id": 10,
    "question": "スレッドプールを使う主な目的は？",
    "choices": [
      "CPUを減らす",
      "メモリを減らす",
      "リソース使用量を制御する",
      "コードを短くする"
    ],
    "answer": 2,
    "explanation": "無制限なスレッド生成を防ぎ、安定性を高めます。"
  },

  {
    "id": 11,
    "question": "DBコネクションプール枯渇時に起こりやすい現象は？",
    "choices": [
      "CPU使用率上昇",
      "リクエスト待ちが発生する",
      "DBが停止する",
      "即時エラーになる"
    ],
    "answer": 1,
    "explanation": "コネクション取得待ちでレスポンスが悪化します。"
  },
  {
    "id": 12,
    "question": "Linuxでロードアベレージが高いのにCPUが空いている場合に疑うのは？",
    "choices": [
      "I/O待ち",
      "CPUバウンド処理",
      "メモリ不足",
      "スワップ未使用"
    ],
    "answer": 0,
    "explanation": "ロードアベレージにはI/O待ちも含まれます。"
  },
  {
    "id": 13,
    "question": "APIの冪等性が重要になるケースは？",
    "choices": [
      "GETリクエスト",
      "リトライが発生する処理",
      "キャッシュ取得",
      "静的ファイル配信"
    ],
    "answer": 1,
    "explanation": "リトライ時に同じ結果になる設計が重要です。"
  },
  {
    "id": 14,
    "question": "分散システムでCAP定理が示しているものは？",
    "choices": [
      "3つ全てを同時に満たせる",
      "2つまでしか同時に満たせない",
      "可用性が最重要",
      "一貫性は不要"
    ],
    "answer": 1,
    "explanation": "Consistency・Availability・Partition toleranceは同時に満たせません。"
  },
  {
    "id": 15,
    "question": "ログに出力すべきでない情報は？",
    "choices": [
      "リクエストID",
      "エラーコード",
      "パスワード",
      "処理時間"
    ],
    "answer": 2,
    "explanation": "機密情報は漏洩リスクがあるためログ出力すべきではありません。"
  },

  {
    "id": 16,
    "question": "Blue-Greenデプロイの主な利点は？",
    "choices": [
      "コスト削減",
      "ダウンタイム削減",
      "コード量削減",
      "テスト不要"
    ],
    "answer": 1,
    "explanation": "切り替えが即時でダウンタイムを最小化できます。"
  },
  {
    "id": 17,
    "question": "DBで外部キー制約を設定するメリットは？",
    "choices": [
      "性能向上",
      "データ整合性保証",
      "ストレージ削減",
      "SQLが短くなる"
    ],
    "answer": 1,
    "explanation": "不正なデータの登録を防げます。"
  },
  {
    "id": 18,
    "question": "障害調査で最初に確認すべき情報は？",
    "choices": [
      "ソースコード",
      "直近の変更",
      "設計書",
      "過去ログ全件"
    ],
    "answer": 1,
    "explanation": "変更点は障害原因になりやすいため最優先です。"
  },
  {
    "id": 19,
    "question": "スケールアップの欠点は？",
    "choices": [
      "実装が難しい",
      "限界がある",
      "設計が複雑",
      "ネットワーク遅延"
    ],
    "answer": 1,
    "explanation": "ハードウェア性能には上限があります。"
  },
  {
    "id": 20,
    "question": "非同期処理を採用する主な理由は？",
    "choices": [
      "コードを短くする",
      "レスポンス改善",
      "DB不要にする",
      "同期処理を禁止する"
    ],
    "answer": 1,
    "explanation": "ユーザー待ち時間を短縮できます。"
  },

  {
    "id": 21,
    "question": "HTTPステータスコード429の意味は？",
    "choices": [
      "認証失敗",
      "リクエスト過多",
      "サーバ内部エラー",
      "リソース未存在"
    ],
    "answer": 1,
    "explanation": "Rate Limit超過を示します。"
  },
  {
    "id": 22,
    "question": "サーキットブレーカーパターンの目的は？",
    "choices": [
      "通信暗号化",
      "障害の連鎖防止",
      "性能向上",
      "コード削減"
    ],
    "answer": 1,
    "explanation": "障害発生時に依存先への負荷を遮断します。"
  },
  {
    "id": 23,
    "question": "GCが頻発すると起こりやすい現象は？",
    "choices": [
      "CPUスパイク",
      "レスポンス遅延",
      "メモリ不足",
      "ディスクフル"
    ],
    "answer": 1,
    "explanation": "GC停止時間によりレスポンスが悪化します。"
  },
  {
    "id": 24,
    "question": "LB配下でセッション管理する一般的な方法は？",
    "choices": [
      "ローカル保存",
      "Sticky Session",
      "DNS切替",
      "DB不要"
    ],
    "answer": 1,
    "explanation": "同一ユーザーを同一サーバへ振り分けます。"
  },
  {
    "id": 25,
    "question": "SQLのEXPLAINで確認できないものは？",
    "choices": [
      "使用インデックス",
      "実行順序",
      "ロック待ち時間",
      "結合方法"
    ],
    "answer": 2,
    "explanation": "ロック待ちは実行計画では確認できません。"
  },

  {
    "id": 26,
    "question": "分散ロックが必要になる代表的なケースは？",
    "choices": [
      "単一バッチ処理",
      "複数ノードでの排他制御",
      "キャッシュ取得",
      "ログ出力"
    ],
    "answer": 1,
    "explanation": "複数ノード環境では分散ロックが必要です。"
  },
  {
    "id": 27,
    "question": "冗長構成の主目的は？",
    "choices": [
      "性能向上",
      "可用性向上",
      "コスト削減",
      "実装簡略化"
    ],
    "answer": 1,
    "explanation": "障害時もサービス継続できるようにします。"
  },
  {
    "id": 28,
    "question": "API設計でバージョニングが必要な理由は？",
    "choices": [
      "コード削減",
      "後方互換性維持",
      "性能向上",
      "実装簡略化"
    ],
    "answer": 1,
    "explanation": "既存クライアントへの影響を防ぎます。"
  },
  {
    "id": 29,
    "question": "CPUバウンド処理の特徴は？",
    "choices": [
      "I/O待ちが多い",
      "CPU使用率が高い",
      "メモリが枯渇する",
      "ネットワーク遅延"
    ],
    "answer": 1,
    "explanation": "計算処理が主でCPUを多く消費します。"
  },
  {
    "id": 30,
    "question": "Observabilityの3本柱に含まれないものは？",
    "choices": [
      "Logs",
      "Metrics",
      "Traces",
      "Alerts"
    ],
    "answer": 3,
    "explanation": "AlertsはObservabilityの結果として利用されます。"
  },

  {
    "id": 31,
    "question": "メッセージキューを使う利点は？",
    "choices": [
      "同期処理が簡単",
      "疎結合化",
      "即時応答",
      "DB不要"
    ],
    "answer": 1,
    "explanation": "システム間の依存を弱められます。"
  },
  {
    "id": 32,
    "question": "TLS証明書の期限切れで起こる影響は？",
    "choices": [
      "通信速度低下",
      "接続拒否",
      "CPU上昇",
      "DB停止"
    ],
    "answer": 1,
    "explanation": "ブラウザやクライアントが接続を拒否します。"
  },
  {
    "id": 33,
    "question": "DBシャーディングの目的は？",
    "choices": [
      "整合性向上",
      "スケールアウト",
      "実装簡略化",
      "バックアップ削減"
    ],
    "answer": 1,
    "explanation": "データを分割して負荷分散します。"
  },
  {
    "id": 34,
    "question": "デッドロックの直接原因は？",
    "choices": [
      "CPU不足",
      "循環待ち",
      "メモリリーク",
      "ネットワーク遅延"
    ],
    "answer": 1,
    "explanation": "複数トランザクションの循環待ちです。"
  },
  {
    "id": 35,
    "question": "HTTP/2の特徴として正しいものは？",
    "choices": [
      "テキスト通信のみ",
      "マルチプレクシング",
      "UDPベース",
      "暗号化不要"
    ],
    "answer": 1,
    "explanation": "1コネクションで複数通信を並列処理できます。"
  },

  {
    "id": 36,
    "question": "メモリスワップが発生すると起こりやすい現象は？",
    "choices": [
      "CPU上昇",
      "レスポンス劣化",
      "ディスク破損",
      "ネットワーク切断"
    ],
    "answer": 1,
    "explanation": "ディスクI/Oが発生し極端に遅くなります。"
  },
  {
    "id": 37,
    "question": "Idempotency Keyの用途は？",
    "choices": [
      "認証",
      "重複処理防止",
      "暗号化",
      "圧縮"
    ],
    "answer": 1,
    "explanation": "同一リクエストの多重実行を防ぎます。"
  },
  {
    "id": 38,
    "question": "インフラ監視で最も後回しにしてはいけないものは？",
    "choices": [
      "ディスク容量",
      "CPU使用率",
      "メモリ",
      "ログサイズ"
    ],
    "answer": 0,
    "explanation": "ディスクフルは即サービス停止につながります。"
  },
  {
    "id": 39,
    "question": "フェイルオーバーの説明として正しいものは？",
    "choices": [
      "負荷分散",
      "障害時の切り替え",
      "性能改善",
      "ログ収集"
    ],
    "answer": 1,
    "explanation": "障害発生時に待機系へ切り替えます。"
  },
  {
    "id": 40,
    "question": "Immutable Infrastructureの利点は？",
    "choices": [
      "手動変更が楽",
      "差分修正",
      "再現性向上",
      "コスト削減"
    ],
    "answer": 2,
    "explanation": "環境差分を排除できます。"
  },

  {
    "id": 41,
    "question": "レイテンシとスループットの違いとして正しいのは？",
    "choices": [
      "同じ意味",
      "応答時間と処理量",
      "CPUとメモリ",
      "通信と計算"
    ],
    "answer": 1,
    "explanation": "レイテンシは応答時間、スループットは処理量です。"
  },
  {
    "id": 42,
    "question": "リードレプリカの主用途は？",
    "choices": [
      "書き込み高速化",
      "読み取り負荷分散",
      "整合性強化",
      "バックアップ代替"
    ],
    "answer": 1,
    "explanation": "参照負荷を分散させます。"
  },
  {
    "id": 43,
    "question": "マイクロサービス化で増えやすい課題は？",
    "choices": [
      "デプロイ回数減少",
      "通信複雑化",
      "実装簡単化",
      "DB統合"
    ],
    "answer": 1,
    "explanation": "サービス間通信が複雑になります。"
  },
  {
    "id": 44,
    "question": "ログに相関IDを付与する目的は？",
    "choices": [
      "容量削減",
      "処理追跡",
      "暗号化",
      "圧縮"
    ],
    "answer": 1,
    "explanation": "リクエスト単位で処理を追跡できます。"
  },
  {
    "id": 45,
    "question": "Rate Limitを設ける主目的は？",
    "choices": [
      "性能向上",
      "不正利用防止",
      "実装簡略化",
      "DB負荷増加"
    ],
    "answer": 1,
    "explanation": "過剰リクエストや攻撃を防ぎます。"
  },

  {
    "id": 46,
    "question": "バックプレッシャーの概念が重要な理由は？",
    "choices": [
      "通信暗号化",
      "過負荷防止",
      "実装簡単化",
      "DB最適化"
    ],
    "answer": 1,
    "explanation": "処理能力を超えた負荷を抑制します。"
  },
  {
    "id": 47,
    "question": "分散トレーシングで分かることは？",
    "choices": [
      "CPU温度",
      "処理経路と遅延",
      "ディスク容量",
      "認証方式"
    ],
    "answer": 1,
    "explanation": "どこで時間がかかっているか把握できます。"
  },
  {
    "id": 48,
    "question": "ロールバックが難しい処理の代表例は？",
    "choices": [
      "DB更新",
      "メール送信",
      "トランザクション",
      "一時ファイル作成"
    ],
    "answer": 1,
    "explanation": "外部副作用は元に戻せません。"
  },
  {
    "id": 49,
    "question": "高トラフィックAPIで最初に検討すべき対策は？",
    "choices": [
      "DB分割",
      "キャッシュ",
      "言語変更",
      "ハード増強"
    ],
    "answer": 1,
    "explanation": "キャッシュは費用対効果が高い対策です。"
  },
  {
    "id": 50,
    "question": "中級以上の技術者に最も重要な姿勢は？",
    "choices": [
      "実装速度",
      "部分最適",
      "全体最適",
      "最新技術追従"
    ],
    "answer": 2,
    "explanation": "システム全体を見て判断できる力が求められます。"
  }
]
